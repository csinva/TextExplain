<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>imodelsx.llm API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>imodelsx.llm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from transformers import (
    T5ForConditionalGeneration,
)
import transformers
from transformers import AutoConfig, AutoModel, AutoTokenizer, AutoModelForCausalLM
import re
from transformers import LlamaForCausalLM, LlamaTokenizer
from typing import Any, Dict, List, Mapping, Optional
import numpy as np
import os.path
from os.path import join, dirname
import os
import pickle as pkl
from scipy.special import softmax
import hashlib
import torch
import time

# change these settings before using these classes!
LLM_CONFIG = {
    &#34;LLM_REPEAT_DELAY&#34;: None,  # how long to wait before recalling a failed llm call (can set to None)
    &#34;CACHE_DIR&#34;: join(
        os.path.expanduser(&#34;~&#34;), &#34;clin/CACHE_OPENAI&#34;
    ),  # path to save cached llm outputs
    &#34;LLAMA_DIR&#34;: join(
        os.path.expanduser(&#34;~&#34;), &#34;llama&#34;
    ),  # path to extracted llama weights
}


def get_llm(
    checkpoint,
    seed=1,
    role: str = None,
    CACHE_DIR=LLM_CONFIG[&#34;CACHE_DIR&#34;],
    LLAMA_DIR=LLM_CONFIG[&#34;LLAMA_DIR&#34;],
):
    &#34;&#34;&#34;Get an LLM with a call function and caching capabilities&#34;&#34;&#34;
    if checkpoint.startswith(&#34;text-da&#34;):
        return LLM_OpenAI(checkpoint, seed=seed, CACHE_DIR=CACHE_DIR)
    elif checkpoint.startswith(&#34;gpt-3&#34;) or checkpoint.startswith(&#34;gpt-4&#34;):
        return LLM_Chat(checkpoint, seed, role, CACHE_DIR)
    else:
        # warning: this sets torch.manual_seed(seed)
        return LLM_HF(checkpoint, seed=seed, CACHE_DIR=CACHE_DIR, LLAMA_DIR=LLAMA_DIR)


def repeatedly_call_with_delay(llm_call):
    def wrapper(*args, **kwargs):
        # Number of seconds to wait between calls (None will not repeat)
        delay = LLM_CONFIG[&#34;LLM_REPEAT_DELAY&#34;]
        response = None
        while response is None:
            try:
                response = llm_call(*args, **kwargs)

                # fix for when this function was returning response rather than string
                # if response is not None and not isinstance(response, str):
                # response = response[&#34;choices&#34;][0][&#34;message&#34;][&#34;content&#34;]
            except Exception as e:
                e = str(e)
                print(e)
                if &#34;does not exist&#34; in e:
                    return None
                elif &#34;maximum context length&#34; in e:
                    return None
                if delay is None:
                    raise e
                else:
                    time.sleep(delay)
        return response

    return wrapper


class LLM_OpenAI:
    def __init__(self, checkpoint, seed, CACHE_DIR):
        import openai

        self.cache_dir = join(
            CACHE_DIR, &#34;cache_openai&#34;, f&#39;{checkpoint.replace(&#34;/&#34;, &#34;_&#34;)}___{seed}&#39;
        )
        self.checkpoint = checkpoint

    @repeatedly_call_with_delay
    def __call__(
        self,
        prompt: str,
        max_new_tokens=250,
        do_sample=True,
        stop=None,
        return_str=True,
    ):
        # cache
        os.makedirs(self.cache_dir, exist_ok=True)
        hash_str = hashlib.sha256(prompt.encode()).hexdigest()
        cache_file = join(self.cache_dir, f&#34;{hash_str}__num_tok={max_new_tokens}.pkl&#34;)
        if os.path.exists(cache_file):
            return pkl.load(open(cache_file, &#34;rb&#34;))

        response = openai.Completion.create(
            engine=self.checkpoint,
            prompt=prompt,
            max_tokens=max_new_tokens,
            temperature=0.1,
            top_p=1,
            frequency_penalty=0.25,  # maximum is 2
            presence_penalty=0,
            stop=stop,
            # stop=[&#34;101&#34;]
        )
        if return_str:
            response = response[&#34;choices&#34;][0][&#34;text&#34;]

        pkl.dump(response, open(cache_file, &#34;wb&#34;))
        return response


class LLM_Chat:
    &#34;&#34;&#34;Chat models take a different format: https://platform.openai.com/docs/guides/chat/introduction&#34;&#34;&#34;

    def __init__(self, checkpoint, seed, role, CACHE_DIR):
        self.cache_dir = join(
            CACHE_DIR, &#34;cache_openai&#34;, f&#39;{checkpoint.replace(&#34;/&#34;, &#34;_&#34;)}___{seed}&#39;
        )
        self.checkpoint = checkpoint
        self.role = role

    @repeatedly_call_with_delay
    def __call__(
        self,
        prompts_list: List[Dict[str, str]],
        max_new_tokens=250,
        stop=None,
        functions: List[Dict] = None,
        return_str=True,
        verbose=True,
        temperature=0.1,
        frequency_penalty=0.25,
    ):
        &#34;&#34;&#34;
        prompts_list: list of dicts, each dict has keys &#39;role&#39; and &#39;content&#39;
            Example: [
                {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant.&#34;},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Who won the world series in 2020?&#34;},
                {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;The Los Angeles Dodgers won the World Series in 2020.&#34;},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Where was it played?&#34;}
            ]
        prompts_list: str
            Alternatively, string which gets formatted into basic prompts_list:
            messages = [
                {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant.&#34;},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &lt;&lt;&lt;&lt;&lt;prompts_list&gt;&gt;&gt;&gt;},
            ]
        &#34;&#34;&#34;
        import openai

        if isinstance(prompts_list, str):
            role = self.role
            if role is None:
                role = &#34;You are a helpful assistant.&#34;
            prompts_list = [
                {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: role},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: prompts_list},
            ]

        assert isinstance(prompts_list, list), prompts_list

        # cache
        os.makedirs(self.cache_dir, exist_ok=True)
        prompts_list_dict = {
            str(i): sorted(v.items()) for i, v in enumerate(prompts_list)
        }
        if not self.checkpoint == &#34;gpt-3.5-turbo&#34;:
            prompts_list_dict[&#34;checkpoint&#34;] = self.checkpoint
        if functions is not None:
            prompts_list_dict[&#34;functions&#34;] = functions
        if temperature &gt; 0.1:
            prompts_list_dict[&#34;temperature&#34;] = temperature
        dict_as_str = json.dumps(prompts_list_dict, sort_keys=True)
        hash_str = hashlib.sha256(dict_as_str.encode()).hexdigest()
        cache_file = join(
            self.cache_dir,
            f&#34;chat__{hash_str}__num_tok={max_new_tokens}.pkl&#34;,
        )
        if os.path.exists(cache_file):
            if verbose:
                print(&#34;cached!&#34;)
                # print(cache_file)
            # print(cache_file)
            return pkl.load(open(cache_file, &#34;rb&#34;))
        if verbose:
            print(&#34;not cached&#34;)

        kwargs = dict(
            model=self.checkpoint,
            messages=prompts_list,
            max_tokens=max_new_tokens,
            temperature=temperature,
            top_p=1,
            frequency_penalty=frequency_penalty,  # maximum is 2
            presence_penalty=0,
            stop=stop,
            # stop=[&#34;101&#34;]
        )
        if functions is not None:
            kwargs[&#34;functions&#34;] = functions

        response = openai.ChatCompletion.create(**kwargs)

        if return_str:
            response = response[&#34;choices&#34;][0][&#34;message&#34;][&#34;content&#34;]
        # print(response)

        pkl.dump(response, open(cache_file, &#34;wb&#34;))
        return response


class LLM_HF:
    def __init__(self, checkpoint, seed, CACHE_DIR, LLAMA_DIR=None):
        # set tokenizer
        if &#34;facebook/opt&#34; in checkpoint:
            # opt can&#39;t use fast tokenizer
            self._tokenizer = AutoTokenizer.from_pretrained(checkpoint, use_fast=False)
        elif &#34;llama_&#34; in checkpoint:
            self._tokenizer = transformers.LlamaTokenizer.from_pretrained(
                join(LLAMA_DIR, checkpoint)
            )
        elif &#34;PMC_LLAMA&#34; in checkpoint:
            self._tokenizer = transformers.LlamaTokenizer.from_pretrained(
                &#34;chaoyi-wu/PMC_LLAMA_7B&#34;
            )
        else:
            self._tokenizer = AutoTokenizer.from_pretrained(checkpoint, use_fast=True)

        # set checkpoint
        if &#34;google/flan&#34; in checkpoint:
            self._model = T5ForConditionalGeneration.from_pretrained(
                checkpoint, device_map=&#34;auto&#34;, torch_dtype=torch.float16
            )
        elif &#34;llama_&#34; in checkpoint:
            self._model = transformers.LlamaForCausalLM.from_pretrained(
                join(LLAMA_DIR, checkpoint),
                device_map=&#34;auto&#34;,
                torch_dtype=torch.float16,
            )
        elif checkpoint == &#34;gpt-xl&#34;:
            self._model = AutoModelForCausalLM.from_pretrained(checkpoint)
        else:
            self._model = AutoModelForCausalLM.from_pretrained(
                checkpoint, device_map=&#34;auto&#34;, torch_dtype=torch.float16
            )
        self.checkpoint = checkpoint
        self.cache_dir = join(
            CACHE_DIR, &#34;cache_hf&#34;, f&#39;{checkpoint.replace(&#34;/&#34;, &#34;_&#34;)}___{seed}&#39;
        )
        self.seed = seed

    def __call__(
        self,
        prompt: str,
        stop: str = None,
        max_new_tokens=20,
        do_sample=False,
        use_cache=True,
    ) -&gt; str:
        &#34;&#34;&#34;Warning: stop not actually used&#34;&#34;&#34;
        with torch.no_grad():
            # cache
            os.makedirs(self.cache_dir, exist_ok=True)
            hash_str = hashlib.sha256(prompt.encode()).hexdigest()
            cache_file = join(
                self.cache_dir, f&#34;{hash_str}__num_tok={max_new_tokens}.pkl&#34;
            )
            if os.path.exists(cache_file) and use_cache:
                return pkl.load(open(cache_file, &#34;rb&#34;))

            # if stop is not None:
            # raise ValueError(&#34;stop kwargs are not permitted.&#34;)
            inputs = self._tokenizer(
                prompt, return_tensors=&#34;pt&#34;, return_attention_mask=True
            ).to(
                self._model.device
            )  # .input_ids.to(&#34;cuda&#34;)
            # stopping_criteria = StoppingCriteriaList([MaxLengthCriteria(max_length=max_tokens)])
            # outputs = self._model.generate(input_ids, max_length=max_tokens, stopping_criteria=stopping_criteria)
            # print(&#39;pad_token&#39;, self._tokenizer.pad_token)
            if self._tokenizer.pad_token_id is None:
                self._tokenizer.pad_token_id = self._tokenizer.eos_token_id
                torch.manual_seed(0)
            outputs = self._model.generate(
                **inputs,
                max_new_tokens=max_new_tokens,
                do_sample=do_sample,
                # pad_token=self._tokenizer.pad_token,
                pad_token_id=self._tokenizer.pad_token_id,
                # top_p=0.92,
                # top_k=0
            )
            out_str = self._tokenizer.decode(outputs[0])
            # print(&#39;out_str&#39;, out_str)
            if &#34;facebook/opt&#34; in self.checkpoint:
                out_str = out_str[len(&#34;&lt;/s&gt;&#34;) + len(prompt) :]
            elif &#34;google/flan&#34; in self.checkpoint:
                # print(&#34;full&#34;, out_str)
                out_str = out_str[len(&#34;&lt;pad&gt;&#34;) : out_str.index(&#34;&lt;/s&gt;&#34;)]
            elif &#34;PMC_LLAMA&#34; in self.checkpoint:
                # print(&#39;here!&#39;, out_str)
                out_str = out_str[len(&#34;&lt;unk&gt;&#34;) + len(prompt) :]
            elif &#34;llama_&#34; in self.checkpoint:
                out_str = out_str[len(&#34;&lt;s&gt;&#34;) + len(prompt) :]
            else:
                out_str = out_str[len(prompt) :]

            if stop is not None and isinstance(stop, str) and stop in out_str:
                out_str = out_str[: out_str.index(stop)]

            pkl.dump(out_str, open(cache_file, &#34;wb&#34;))
            return out_str

    def _get_logit_for_target_token(self, prompt: str, target_token_str: str) -&gt; float:
        &#34;&#34;&#34;Get logits target_token_str
        This is weird when token_output_ids represents multiple tokens
        It currently will only take the first token
        &#34;&#34;&#34;
        # Get first token id in target_token_str
        target_token_id = self._tokenizer(target_token_str)[&#34;input_ids&#34;][0]

        # get prob of target token
        inputs = self._tokenizer(
            prompt,
            return_tensors=&#34;pt&#34;,
            return_attention_mask=True,
            padding=False,
            truncation=False,
        ).to(self._model.device)
        # shape is (batch_size, seq_len, vocab_size)
        logits = self._model(**inputs)[&#34;logits&#34;].detach().cpu()
        # shape is (vocab_size,)
        probs_next_token = softmax(logits[0, -1, :].numpy().flatten())
        return probs_next_token[target_token_id]


if __name__ == &#34;__main__&#34;:
    # llm = get_llm(&#34;text-davinci-003&#34;)
    # text = llm(&#34;What do these have in common? Horse, &#34;)
    # print(&#34;text&#34;, text)

    # llm = get_llm(&#34;gpt2&#34;)
    # text = llm(
    # &#34;&#34;&#34;Continue this list
    # - apple
    # - banana
    # -&#34;&#34;&#34;
    # )
    # print(&#34;text&#34;, text)
    # tokenizer = transformers.LlamaTokenizer.from_pretrained(&#34;chaoyi-wu/PMC_LLAMA_7B&#34;)
    # model = transformers.LlamaForCausalLM.from_pretrained(&#34;chaoyi-wu/PMC_LLAMA_7B&#34;)

    # llm = get_llm(&#34;chaoyi-wu/PMC_LLAMA_7B&#34;)
    llm = get_llm(&#34;llama_65b&#34;)
    text = llm(
        &#34;&#34;&#34;Continue this list
- red
- orange
- yellow
- green
-&#34;&#34;&#34;,
        use_cache=False,
    )
    print(text)
    print(&#34;\n\n&#34;)
    print(repr(text))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="imodelsx.llm.get_llm"><code class="name flex">
<span>def <span class="ident">get_llm</span></span>(<span>checkpoint, seed=1, role: str = None, CACHE_DIR='/home/chansingh/clin/CACHE_OPENAI', LLAMA_DIR='/home/chansingh/llama')</span>
</code></dt>
<dd>
<div class="desc"><p>Get an LLM with a call function and caching capabilities</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_llm(
    checkpoint,
    seed=1,
    role: str = None,
    CACHE_DIR=LLM_CONFIG[&#34;CACHE_DIR&#34;],
    LLAMA_DIR=LLM_CONFIG[&#34;LLAMA_DIR&#34;],
):
    &#34;&#34;&#34;Get an LLM with a call function and caching capabilities&#34;&#34;&#34;
    if checkpoint.startswith(&#34;text-da&#34;):
        return LLM_OpenAI(checkpoint, seed=seed, CACHE_DIR=CACHE_DIR)
    elif checkpoint.startswith(&#34;gpt-3&#34;) or checkpoint.startswith(&#34;gpt-4&#34;):
        return LLM_Chat(checkpoint, seed, role, CACHE_DIR)
    else:
        # warning: this sets torch.manual_seed(seed)
        return LLM_HF(checkpoint, seed=seed, CACHE_DIR=CACHE_DIR, LLAMA_DIR=LLAMA_DIR)</code></pre>
</details>
</dd>
<dt id="imodelsx.llm.repeatedly_call_with_delay"><code class="name flex">
<span>def <span class="ident">repeatedly_call_with_delay</span></span>(<span>llm_call)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeatedly_call_with_delay(llm_call):
    def wrapper(*args, **kwargs):
        # Number of seconds to wait between calls (None will not repeat)
        delay = LLM_CONFIG[&#34;LLM_REPEAT_DELAY&#34;]
        response = None
        while response is None:
            try:
                response = llm_call(*args, **kwargs)

                # fix for when this function was returning response rather than string
                # if response is not None and not isinstance(response, str):
                # response = response[&#34;choices&#34;][0][&#34;message&#34;][&#34;content&#34;]
            except Exception as e:
                e = str(e)
                print(e)
                if &#34;does not exist&#34; in e:
                    return None
                elif &#34;maximum context length&#34; in e:
                    return None
                if delay is None:
                    raise e
                else:
                    time.sleep(delay)
        return response

    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="imodelsx.llm.LLM_Chat"><code class="flex name class">
<span>class <span class="ident">LLM_Chat</span></span>
<span>(</span><span>checkpoint, seed, role, CACHE_DIR)</span>
</code></dt>
<dd>
<div class="desc"><p>Chat models take a different format: <a href="https://platform.openai.com/docs/guides/chat/introduction">https://platform.openai.com/docs/guides/chat/introduction</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLM_Chat:
    &#34;&#34;&#34;Chat models take a different format: https://platform.openai.com/docs/guides/chat/introduction&#34;&#34;&#34;

    def __init__(self, checkpoint, seed, role, CACHE_DIR):
        self.cache_dir = join(
            CACHE_DIR, &#34;cache_openai&#34;, f&#39;{checkpoint.replace(&#34;/&#34;, &#34;_&#34;)}___{seed}&#39;
        )
        self.checkpoint = checkpoint
        self.role = role

    @repeatedly_call_with_delay
    def __call__(
        self,
        prompts_list: List[Dict[str, str]],
        max_new_tokens=250,
        stop=None,
        functions: List[Dict] = None,
        return_str=True,
        verbose=True,
        temperature=0.1,
        frequency_penalty=0.25,
    ):
        &#34;&#34;&#34;
        prompts_list: list of dicts, each dict has keys &#39;role&#39; and &#39;content&#39;
            Example: [
                {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant.&#34;},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Who won the world series in 2020?&#34;},
                {&#34;role&#34;: &#34;assistant&#34;, &#34;content&#34;: &#34;The Los Angeles Dodgers won the World Series in 2020.&#34;},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;Where was it played?&#34;}
            ]
        prompts_list: str
            Alternatively, string which gets formatted into basic prompts_list:
            messages = [
                {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: &#34;You are a helpful assistant.&#34;},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &lt;&lt;&lt;&lt;&lt;prompts_list&gt;&gt;&gt;&gt;},
            ]
        &#34;&#34;&#34;
        import openai

        if isinstance(prompts_list, str):
            role = self.role
            if role is None:
                role = &#34;You are a helpful assistant.&#34;
            prompts_list = [
                {&#34;role&#34;: &#34;system&#34;, &#34;content&#34;: role},
                {&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: prompts_list},
            ]

        assert isinstance(prompts_list, list), prompts_list

        # cache
        os.makedirs(self.cache_dir, exist_ok=True)
        prompts_list_dict = {
            str(i): sorted(v.items()) for i, v in enumerate(prompts_list)
        }
        if not self.checkpoint == &#34;gpt-3.5-turbo&#34;:
            prompts_list_dict[&#34;checkpoint&#34;] = self.checkpoint
        if functions is not None:
            prompts_list_dict[&#34;functions&#34;] = functions
        if temperature &gt; 0.1:
            prompts_list_dict[&#34;temperature&#34;] = temperature
        dict_as_str = json.dumps(prompts_list_dict, sort_keys=True)
        hash_str = hashlib.sha256(dict_as_str.encode()).hexdigest()
        cache_file = join(
            self.cache_dir,
            f&#34;chat__{hash_str}__num_tok={max_new_tokens}.pkl&#34;,
        )
        if os.path.exists(cache_file):
            if verbose:
                print(&#34;cached!&#34;)
                # print(cache_file)
            # print(cache_file)
            return pkl.load(open(cache_file, &#34;rb&#34;))
        if verbose:
            print(&#34;not cached&#34;)

        kwargs = dict(
            model=self.checkpoint,
            messages=prompts_list,
            max_tokens=max_new_tokens,
            temperature=temperature,
            top_p=1,
            frequency_penalty=frequency_penalty,  # maximum is 2
            presence_penalty=0,
            stop=stop,
            # stop=[&#34;101&#34;]
        )
        if functions is not None:
            kwargs[&#34;functions&#34;] = functions

        response = openai.ChatCompletion.create(**kwargs)

        if return_str:
            response = response[&#34;choices&#34;][0][&#34;message&#34;][&#34;content&#34;]
        # print(response)

        pkl.dump(response, open(cache_file, &#34;wb&#34;))
        return response</code></pre>
</details>
</dd>
<dt id="imodelsx.llm.LLM_HF"><code class="flex name class">
<span>class <span class="ident">LLM_HF</span></span>
<span>(</span><span>checkpoint, seed, CACHE_DIR, LLAMA_DIR=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLM_HF:
    def __init__(self, checkpoint, seed, CACHE_DIR, LLAMA_DIR=None):
        # set tokenizer
        if &#34;facebook/opt&#34; in checkpoint:
            # opt can&#39;t use fast tokenizer
            self._tokenizer = AutoTokenizer.from_pretrained(checkpoint, use_fast=False)
        elif &#34;llama_&#34; in checkpoint:
            self._tokenizer = transformers.LlamaTokenizer.from_pretrained(
                join(LLAMA_DIR, checkpoint)
            )
        elif &#34;PMC_LLAMA&#34; in checkpoint:
            self._tokenizer = transformers.LlamaTokenizer.from_pretrained(
                &#34;chaoyi-wu/PMC_LLAMA_7B&#34;
            )
        else:
            self._tokenizer = AutoTokenizer.from_pretrained(checkpoint, use_fast=True)

        # set checkpoint
        if &#34;google/flan&#34; in checkpoint:
            self._model = T5ForConditionalGeneration.from_pretrained(
                checkpoint, device_map=&#34;auto&#34;, torch_dtype=torch.float16
            )
        elif &#34;llama_&#34; in checkpoint:
            self._model = transformers.LlamaForCausalLM.from_pretrained(
                join(LLAMA_DIR, checkpoint),
                device_map=&#34;auto&#34;,
                torch_dtype=torch.float16,
            )
        elif checkpoint == &#34;gpt-xl&#34;:
            self._model = AutoModelForCausalLM.from_pretrained(checkpoint)
        else:
            self._model = AutoModelForCausalLM.from_pretrained(
                checkpoint, device_map=&#34;auto&#34;, torch_dtype=torch.float16
            )
        self.checkpoint = checkpoint
        self.cache_dir = join(
            CACHE_DIR, &#34;cache_hf&#34;, f&#39;{checkpoint.replace(&#34;/&#34;, &#34;_&#34;)}___{seed}&#39;
        )
        self.seed = seed

    def __call__(
        self,
        prompt: str,
        stop: str = None,
        max_new_tokens=20,
        do_sample=False,
        use_cache=True,
    ) -&gt; str:
        &#34;&#34;&#34;Warning: stop not actually used&#34;&#34;&#34;
        with torch.no_grad():
            # cache
            os.makedirs(self.cache_dir, exist_ok=True)
            hash_str = hashlib.sha256(prompt.encode()).hexdigest()
            cache_file = join(
                self.cache_dir, f&#34;{hash_str}__num_tok={max_new_tokens}.pkl&#34;
            )
            if os.path.exists(cache_file) and use_cache:
                return pkl.load(open(cache_file, &#34;rb&#34;))

            # if stop is not None:
            # raise ValueError(&#34;stop kwargs are not permitted.&#34;)
            inputs = self._tokenizer(
                prompt, return_tensors=&#34;pt&#34;, return_attention_mask=True
            ).to(
                self._model.device
            )  # .input_ids.to(&#34;cuda&#34;)
            # stopping_criteria = StoppingCriteriaList([MaxLengthCriteria(max_length=max_tokens)])
            # outputs = self._model.generate(input_ids, max_length=max_tokens, stopping_criteria=stopping_criteria)
            # print(&#39;pad_token&#39;, self._tokenizer.pad_token)
            if self._tokenizer.pad_token_id is None:
                self._tokenizer.pad_token_id = self._tokenizer.eos_token_id
                torch.manual_seed(0)
            outputs = self._model.generate(
                **inputs,
                max_new_tokens=max_new_tokens,
                do_sample=do_sample,
                # pad_token=self._tokenizer.pad_token,
                pad_token_id=self._tokenizer.pad_token_id,
                # top_p=0.92,
                # top_k=0
            )
            out_str = self._tokenizer.decode(outputs[0])
            # print(&#39;out_str&#39;, out_str)
            if &#34;facebook/opt&#34; in self.checkpoint:
                out_str = out_str[len(&#34;&lt;/s&gt;&#34;) + len(prompt) :]
            elif &#34;google/flan&#34; in self.checkpoint:
                # print(&#34;full&#34;, out_str)
                out_str = out_str[len(&#34;&lt;pad&gt;&#34;) : out_str.index(&#34;&lt;/s&gt;&#34;)]
            elif &#34;PMC_LLAMA&#34; in self.checkpoint:
                # print(&#39;here!&#39;, out_str)
                out_str = out_str[len(&#34;&lt;unk&gt;&#34;) + len(prompt) :]
            elif &#34;llama_&#34; in self.checkpoint:
                out_str = out_str[len(&#34;&lt;s&gt;&#34;) + len(prompt) :]
            else:
                out_str = out_str[len(prompt) :]

            if stop is not None and isinstance(stop, str) and stop in out_str:
                out_str = out_str[: out_str.index(stop)]

            pkl.dump(out_str, open(cache_file, &#34;wb&#34;))
            return out_str

    def _get_logit_for_target_token(self, prompt: str, target_token_str: str) -&gt; float:
        &#34;&#34;&#34;Get logits target_token_str
        This is weird when token_output_ids represents multiple tokens
        It currently will only take the first token
        &#34;&#34;&#34;
        # Get first token id in target_token_str
        target_token_id = self._tokenizer(target_token_str)[&#34;input_ids&#34;][0]

        # get prob of target token
        inputs = self._tokenizer(
            prompt,
            return_tensors=&#34;pt&#34;,
            return_attention_mask=True,
            padding=False,
            truncation=False,
        ).to(self._model.device)
        # shape is (batch_size, seq_len, vocab_size)
        logits = self._model(**inputs)[&#34;logits&#34;].detach().cpu()
        # shape is (vocab_size,)
        probs_next_token = softmax(logits[0, -1, :].numpy().flatten())
        return probs_next_token[target_token_id]</code></pre>
</details>
</dd>
<dt id="imodelsx.llm.LLM_OpenAI"><code class="flex name class">
<span>class <span class="ident">LLM_OpenAI</span></span>
<span>(</span><span>checkpoint, seed, CACHE_DIR)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LLM_OpenAI:
    def __init__(self, checkpoint, seed, CACHE_DIR):
        import openai

        self.cache_dir = join(
            CACHE_DIR, &#34;cache_openai&#34;, f&#39;{checkpoint.replace(&#34;/&#34;, &#34;_&#34;)}___{seed}&#39;
        )
        self.checkpoint = checkpoint

    @repeatedly_call_with_delay
    def __call__(
        self,
        prompt: str,
        max_new_tokens=250,
        do_sample=True,
        stop=None,
        return_str=True,
    ):
        # cache
        os.makedirs(self.cache_dir, exist_ok=True)
        hash_str = hashlib.sha256(prompt.encode()).hexdigest()
        cache_file = join(self.cache_dir, f&#34;{hash_str}__num_tok={max_new_tokens}.pkl&#34;)
        if os.path.exists(cache_file):
            return pkl.load(open(cache_file, &#34;rb&#34;))

        response = openai.Completion.create(
            engine=self.checkpoint,
            prompt=prompt,
            max_tokens=max_new_tokens,
            temperature=0.1,
            top_p=1,
            frequency_penalty=0.25,  # maximum is 2
            presence_penalty=0,
            stop=stop,
            # stop=[&#34;101&#34;]
        )
        if return_str:
            response = response[&#34;choices&#34;][0][&#34;text&#34;]

        pkl.dump(response, open(cache_file, &#34;wb&#34;))
        return response</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="imodelsx" href="index.html">imodelsx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="imodelsx.llm.get_llm" href="#imodelsx.llm.get_llm">get_llm</a></code></li>
<li><code><a title="imodelsx.llm.repeatedly_call_with_delay" href="#imodelsx.llm.repeatedly_call_with_delay">repeatedly_call_with_delay</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="imodelsx.llm.LLM_Chat" href="#imodelsx.llm.LLM_Chat">LLM_Chat</a></code></h4>
</li>
<li>
<h4><code><a title="imodelsx.llm.LLM_HF" href="#imodelsx.llm.LLM_HF">LLM_HF</a></code></h4>
</li>
<li>
<h4><code><a title="imodelsx.llm.LLM_OpenAI" href="#imodelsx.llm.LLM_OpenAI">LLM_OpenAI</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>